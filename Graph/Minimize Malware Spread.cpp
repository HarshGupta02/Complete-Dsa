/*
we know that the graph is undirected and self loops are of no importance. we also
seen that since two connected nodes spread malware so consider concept of 
connected nodes.

so in each component, we see that if there exists only 1 malicious node so it can be removed
else if a connected component has more than one malicious nodes so either removing any one 
will not effect the other nodes.

*/

class DSU {
public:
    int get_parent(int a, vector<int> &parent){
        return (a == parent[a] ? a : get_parent(parent[a], parent));
    }
    
    void mergee(int a, int b, vector<int> &parent, vector<int> &size){
        // rank compression or size compression are both optimal
        a = get_parent(a, parent);
        b = get_parent(b, parent);
        if(size[a] > size[b]) {
            parent[b] = a;
            size[a] += size[b];
        }else {
            parent[a] = b;
            size[b] += size[a];
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size(), m = initial.size();
        vector<int> parent(n), size(n, 1);
        for(int i = 0; i < n; i ++) parent[i] = i;
        DSU dsu;
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n; j ++){
                if(graph[i][j] == 1){
                    if(dsu.get_parent(i, parent) != dsu.get_parent(j, parent)){
                        dsu.mergee(i, j, parent, size);
                    }
                }
            }
        }
        map<int, int> mp;
        for(auto node : initial){
            int par = dsu.get_parent(node, parent);
            mp[par] ++;
        }
        int ans = -1, max_size = -1;
        for(auto node : initial){
            int par = dsu.get_parent(node, parent);
            if(mp[par] == 1 and size[par] >= max_size){
                if(max_size == size[par]){
                    ans = min(ans, node);
                }else ans = node;
                max_size = size[par];
            }
        }
        if(ans == -1) return *min_element(begin(initial), end(initial));
        return ans;
    }
};