/*
so here we first create a graph without the malicious nodes and then for each malicious node, we 
find it's neighbours and the size of their absolute parent and sum then up for each malicious node
and then take the max of all.
*/

class DSU{
public:
    
    int get_parent(int a, vector<int> &parent){
        return (a == parent[a] ? a : get_parent(parent[a], parent));
    }
    
    void mergee(int a, int b, vector<int> &parent, vector<int> &size){
        a = get_parent(a, parent);
        b = get_parent(b, parent);
        if(size[a] > size[b]) {
            parent[b] = a;
            size[a] += size[b];
        }else {
            parent[a] = b;
            size[b] += size[a];
        }
    }
    
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> parent(n), size(n, 1);
        for(int i = 0; i < n; i ++) parent[i] = i;
        DSU dsu;
        set<int> s;
        for(auto node : initial) s.insert(node);
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n; j ++){
                if(graph[i][j] == 1 and s.find(i) == s.end() and s.find(j) == s.end()){
                    if(dsu.get_parent(i, parent) != dsu.get_parent(j, parent))
                        dsu.mergee(i, j, parent, size);
                }
            }
        }
        map<int, set<int>> mp;
        vector<int> infected(n, 0);
        for(auto node : initial){
            for(int j = 0; j < n; j ++){
                if(graph[node][j] == 1 and node != j and s.find(j) == s.end()){
                    int par = dsu.get_parent(j, parent);
                    if(mp[node].find(par) == mp[node].end()){
                        infected[par] ++;
                        mp[node].insert(par);
                    }
                }
            }
        }
        int ans = -1, m = -1;
        for(auto node : initial){
            int total = 0;
            set<int> pars = mp[node];
            for(auto p : pars){
                if(infected[p] == 1) total += size[p];
            }
            if(total >= m){
                if(total == m) ans = min(ans, node);
                else ans = node;
                m = total;
            }
        }
        if(ans == -1) return *min_element(begin(initial), end(initial));
        return ans;
    }
};